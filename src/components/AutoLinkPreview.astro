---

// Define the props
interface AutoLinkPreviewProps {
  url: string;
  className?: string;
  fallbackTitle?: string;
  fallbackDescription?: string;
  fallbackImage?: string;
  tags?: string[];
}

const getDomain = (url: string): string => {
  try {
    const urlObj = new URL(url);
    return urlObj.hostname.replace('www.', '');
  } catch {
    return 'External Link';
  }
};

const getFaviconUrl = (url: string): string => {
  try {
    const urlObj = new URL(url);
    return `${urlObj.protocol}//${urlObj.hostname}/favicon.ico`;
  } catch {
    return '';
  }
};

const createEnhancedMetadata = (url: string, fallbackTitle?: string, fallbackDescription?: string, fallbackImage?: string) => {
  const domain = getDomain(url);
  const favicon = getFaviconUrl(url);
  return {
    title: fallbackTitle || domain,
    description: fallbackDescription || `Conteúdo de ${domain}`,
    image: fallbackImage || '',
    url,
    domain,
    favicon,
    siteName: domain,
    type: 'article',
  };
};
// Import the extraction utilities
import { extractMetadataWithCheerio, generateUrlVariants, createFallbackMetadata } from '../lib/ogExtractor';

const fetchMetadata = async (url: string, fallbackTitle?: string, fallbackDescription?: string, fallbackImage?: string) => {
  // Always have fallback ready
  const fallbackData = createEnhancedMetadata(url, fallbackTitle, fallbackDescription, fallbackImage);
  
  try {
    // Race between metadata extraction and timeout
    const metadataPromise = extractMetadataWithCheerio(url);
    const timeoutPromise = new Promise<null>((resolve) => 
      setTimeout(() => resolve(null), 1500) // 1.5 second max timeout
    );
    
    const metadata = await Promise.race([metadataPromise, timeoutPromise]);
    
    // If we got metadata within timeout, use it
    if (metadata && (metadata.ogTitle || metadata.ogDescription || metadata.ogImage)) {
      return {
        title: metadata.ogTitle || fallbackTitle || getDomain(url),
        description: metadata.ogDescription || fallbackDescription || `Conteúdo de ${getDomain(url)}`,
        image: metadata.ogImage || fallbackImage || '',
        url,
        domain: getDomain(url),
        favicon: getFaviconUrl(url),
        siteName: metadata.ogSiteName || getDomain(url),
        type: metadata.ogType || 'article',
      };
    }
    
    // Timeout or no useful metadata - use fallback
    return fallbackData;
    
  } catch (err) {
    // Any error - immediately return fallback
    return fallbackData;
  }
};

// Fetch metadata on the server side
const { url, className = '', fallbackTitle, fallbackDescription, fallbackImage, tags } = Astro.props;
const metadata = await fetchMetadata(url, fallbackTitle, fallbackDescription, fallbackImage);
---

<a href={url} target={url.startsWith('http') ? '_blank' : undefined} rel="noopener noreferrer" class={`group block bg-white rounded-xl border border-gray-200 hover:border-gray-300 hover:shadow-lg transition-all duration-200 overflow-hidden ${className}`}>
  {(metadata.image || fallbackImage) && (
    <div class="aspect-video overflow-hidden bg-gray-100">
      <img src={metadata.image || fallbackImage} alt="" class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300" loading="lazy" />
    </div>
  )}
  <div class="p-6">
    {Array.isArray(tags) && tags.length > 0 && (
      <div class="mb-3 flex items-center gap-2">
        {tags.slice(0, 2).map((t) => (
          <span key={t} class="inline-flex items-center rounded-full bg-emerald-100 px-2.5 py-0.5 text-xs font-medium text-emerald-800">{t}</span>
        ))}
      </div>
    )}
    {metadata.title && (
      <h3 class="font-semibold text-gray-900 text-lg mb-2 group-hover:text-blue-600 transition-colors line-clamp-2">{metadata.title}</h3>
    )}
    {metadata.description && (
      <p class="text-gray-600 text-sm mb-4 line-clamp-3">{metadata.description}</p>
    )}
    <div class="flex items-center justify-between">
      <div class="flex items-center space-x-2">
        {metadata.favicon && (
          <img src={metadata.favicon} alt="" class="w-4 h-4 rounded" onError={(e) => { (e.currentTarget as HTMLImageElement).style.display = 'none'; }} />
        )}
        <div class="text-xs">
          <div class="font-medium text-blue-600">{metadata.siteName}</div>
          <div class="text-gray-500">{metadata.domain}</div>
        </div>
      </div>
      <div class="flex items-center space-x-2">
        <div class="flex items-center space-x-1 text-xs text-gray-400">
          <span>Ler</span>
          <svg class="w-4 h-4 group-hover:text-blue-500 transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" /></svg>
        </div>
      </div>
    </div>
  </div>
</a>
